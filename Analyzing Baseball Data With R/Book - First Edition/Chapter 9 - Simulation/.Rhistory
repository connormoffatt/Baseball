C.SB=sum(SB, na.rm=TRUE))
# Calculalte batting and slugging
C.totals$C.AVG <- with(C.totals, C.H / C.AB)
C.totals$C.SLG <- with(C.totals, C.H - C.2B - C.3B - C.HR + 2*C.2B + 3*C.3B
+ 4*C.HR)
# Compute Career totals with fielding totals. Each position is given an
# associated fielding value for similarity scores
C.totals <- merge(C.totals, Fielding.2000)
C.totals <- with(C.totals,
ifelse(POS=="C", 240,
ifelse(POS=="SS", 168,
ifelse(POS=="2B", 132,
ifelse(POS=="3B", 84,
ifelse(POS=="OF", 48,
ifelse(POS=="1B", 12, 0)))))))
# Computing Bill James Similarity Score
similar <- function(p, number=10){
P <- subset(C.totals, playerID==p)
C.totals$SS <- with(C.totals,
1000 -
floor(abs(C.G - P$C.G) / 20) -
floor(abs(C.AB - P$C.AB) / 75) -
floor(abs(C.R - P$C.R) / 10) -
floor(abs(C.H - P$C.H) / 15) -
floor(abs(C.2B - P$C.2B) / 5) -
floor(abs(C.3B - P$C.3B) / 4) -
floor(abs(C.HR - P$C.HR) / 2) -
floor(abs(C.RBI - P$C.RBI) / 10) -
floor(abs(C.BB - P$C.BB) / 25) -
floor(abs(C.SO - P$C.SO) / 150) -
floor(abs(C.SB - P$C.SB) / 20) -
floor(abs(C.AVG - P$C.AVG) / 0.001) -
floor(abs(C.SLG - P$C.SLG) / 0.002) -
abs(VALUE.POS - P$VALUE.POS))
C.totals <- C.totals[order(C.total$SS, decreasing==TRUE)]
C.totals[1:number,]
}
similar(Mantle.id, 6)
C.totals
C.totals <- ddply(Batting.2000, .(playerID), summarize,
C.G=sum(G, na.rm=TRUE),
C.AB=sum(AB, na.rm=TRUE),
C.R=sum(R, na.rm=TRUE),
C.H=sum(H, na.rm=TRUE),
C.2B=sum(X2B, na.rm=TRUE),
C.3B=sum(X3B, na.rm=TRUE),
C.HR=sum(HR, na.rm=TRUE),
C.RBI=sum(RBI, na.rm=TRUE),
C.BB=sum(BB, na.rm=TRUE),
C.SO=sum(SO, na.rm=TRUE),
C.SB=sum(SB, na.rm=TRUE))
C.totals
# Calculalte batting and slugging
C.totals$C.AVG <- with(C.totals, C.H / C.AB)
C.totals$C.SLG <- with(C.totals, C.H - C.2B - C.3B - C.HR + 2*C.2B + 3*C.3B
+ 4*C.HR)
C.totals
# Compute Career totals with fielding totals. Each position is given an
# associated fielding value for similarity scores
C.totals <- merge(C.totals, Fielding.2000)
C.totals
C.totals <- with(C.totals,
ifelse(POS=="C", 240,
ifelse(POS=="SS", 168,
ifelse(POS=="2B", 132,
ifelse(POS=="3B", 84,
ifelse(POS=="OF", 48,
ifelse(POS=="1B", 12, 0)))))))
C.totals
# Create dataframe with fielding positions and playerIDs for players > 2000 PA
PLAYER <- as.character(unique(Batting.2000$playerID))
POSITIONS <- sapply(PLAYER, find.position)
Fielding.2000 <- data.frame(playerID=names(POSITIONS), POS=POSITIONS)
Batting.2000 <- merge(Batting.2000, Fielding.2000)
# Calculate Career Statistics
C.totals <- ddply(Batting.2000, .(playerID), summarize,
C.G=sum(G, na.rm=TRUE),
C.AB=sum(AB, na.rm=TRUE),
C.R=sum(R, na.rm=TRUE),
C.H=sum(H, na.rm=TRUE),
C.2B=sum(X2B, na.rm=TRUE),
C.3B=sum(X3B, na.rm=TRUE),
C.HR=sum(HR, na.rm=TRUE),
C.RBI=sum(RBI, na.rm=TRUE),
C.BB=sum(BB, na.rm=TRUE),
C.SO=sum(SO, na.rm=TRUE),
C.SB=sum(SB, na.rm=TRUE))
# Calculalte batting and slugging
C.totals$C.AVG <- with(C.totals, C.H / C.AB)
C.totals$C.SLG <- with(C.totals, C.H - C.2B - C.3B - C.HR + 2*C.2B + 3*C.3B
+ 4*C.HR)
# Compute Career totals with fielding totals. Each position is given an
# associated fielding value for similarity scores
C.totals <- merge(C.totals, Fielding.2000)
C.totals$Value.POS <- with(C.totals,
ifelse(POS=="C", 240,
ifelse(POS=="SS", 168,
ifelse(POS=="2B", 132,
ifelse(POS=="3B", 84,
ifelse(POS=="OF", 48,
ifelse(POS=="1B", 12, 0)))))))
# Computing Bill James Similarity Score
similar <- function(p, number=10){
P <- subset(C.totals, playerID==p)
C.totals$SS <- with(C.totals,
1000 -
floor(abs(C.G - P$C.G) / 20) -
floor(abs(C.AB - P$C.AB) / 75) -
floor(abs(C.R - P$C.R) / 10) -
floor(abs(C.H - P$C.H) / 15) -
floor(abs(C.2B - P$C.2B) / 5) -
floor(abs(C.3B - P$C.3B) / 4) -
floor(abs(C.HR - P$C.HR) / 2) -
floor(abs(C.RBI - P$C.RBI) / 10) -
floor(abs(C.BB - P$C.BB) / 25) -
floor(abs(C.SO - P$C.SO) / 150) -
floor(abs(C.SB - P$C.SB) / 20) -
floor(abs(C.AVG - P$C.AVG) / 0.001) -
floor(abs(C.SLG - P$C.SLG) / 0.002) -
abs(VALUE.POS - P$VALUE.POS))
C.totals <- C.totals[order(C.total$SS, decreasing==TRUE)]
C.totals[1:number,]
}
similar(Mantle.id, 6)
Mantle.id
rm(list=ls())
chapter_path = "C:/Users/conno/Documents/GitHub/Baseball/Analyzing Baseball Data With R/Book - First Edition/Chapter 8 - Career Trajectories"
setwd(chapter_path)
Fielding <- read.csv("Fielding.csv")
Batting <- read.csv("Batting.csv")
People <- read.csv("People.csv")
mantle.info <- subset(People, nameFirst=="Mickey" & nameLast=="Mantle")
mantle.id <- as.character(mantle.info$playerID)
# Analyze trajectories by position
# First only get batters with 2000 Career PA
library(plyr)
AB.totals <- ddply(Batting, .(playerID), summarize,
Career.AB=sum(AB, na.rm=TRUE))
Batting <- merge(Batting, AB.totals)
Batting.2000 <- subset(Batting, Career.AB > 2000)
# Create function to find a player's most common position
find.position <- function(p){
positions <- c("OF", "1B", "2B", "3B", "SS", "C", "P", "DH")
d <- subset(Fielding, playerID==p)
count.games <- function(po)
sum(subset(d, POS==po)$G)
FLD <- sapply(positions, count.games)
positions[FLD == max(FLD)][1]
}
# Create dataframe with fielding positions and playerIDs for players > 2000 PA
PLAYER <- as.character(unique(Batting.2000$playerID))
POSITIONS <- sapply(PLAYER, find.position)
Fielding.2000 <- data.frame(playerID=names(POSITIONS), POS=POSITIONS)
Batting.2000 <- merge(Batting.2000, Fielding.2000)
# Calculate Career Statistics
C.totals <- ddply(Batting.2000, .(playerID), summarize,
C.G=sum(G, na.rm=TRUE),
C.AB=sum(AB, na.rm=TRUE),
C.R=sum(R, na.rm=TRUE),
C.H=sum(H, na.rm=TRUE),
C.2B=sum(X2B, na.rm=TRUE),
C.3B=sum(X3B, na.rm=TRUE),
C.HR=sum(HR, na.rm=TRUE),
C.RBI=sum(RBI, na.rm=TRUE),
C.BB=sum(BB, na.rm=TRUE),
C.SO=sum(SO, na.rm=TRUE),
C.SB=sum(SB, na.rm=TRUE))
# Calculalte batting and slugging
C.totals$C.AVG <- with(C.totals, C.H / C.AB)
C.totals$C.SLG <- with(C.totals, C.H - C.2B - C.3B - C.HR + 2*C.2B + 3*C.3B
+ 4*C.HR)
# Compute Career totals with fielding totals. Each position is given an
# associated fielding value for similarity scores
C.totals <- merge(C.totals, Fielding.2000)
C.totals$Value.POS <- with(C.totals,
ifelse(POS=="C", 240,
ifelse(POS=="SS", 168,
ifelse(POS=="2B", 132,
ifelse(POS=="3B", 84,
ifelse(POS=="OF", 48,
ifelse(POS=="1B", 12, 0)))))))
# Computing Bill James Similarity Score
similar <- function(p, number=10){
P <- subset(C.totals, playerID==p)
C.totals$SS <- with(C.totals,
1000 -
floor(abs(C.G - P$C.G) / 20) -
floor(abs(C.AB - P$C.AB) / 75) -
floor(abs(C.R - P$C.R) / 10) -
floor(abs(C.H - P$C.H) / 15) -
floor(abs(C.2B - P$C.2B) / 5) -
floor(abs(C.3B - P$C.3B) / 4) -
floor(abs(C.HR - P$C.HR) / 2) -
floor(abs(C.RBI - P$C.RBI) / 10) -
floor(abs(C.BB - P$C.BB) / 25) -
floor(abs(C.SO - P$C.SO) / 150) -
floor(abs(C.SB - P$C.SB) / 20) -
floor(abs(C.AVG - P$C.AVG) / 0.001) -
floor(abs(C.SLG - P$C.SLG) / 0.002) -
abs(VALUE.POS - P$VALUE.POS))
C.totals <- C.totals[order(C.total$SS, decreasing==TRUE)]
C.totals[1:number,]
}
similar(Mantle.id, 6)
similar(Mantle.id, 6)
Mantle.id
People <- read.csv("People.csv")
mantle.info <- subset(People, nameFirst=="Mickey" & nameLast=="Mantle")
mantle.id <- as.character(mantle.info$playerID)
similar(mantle.id, 6)
C.totals$Value.POS <- with(C.totals,
ifelse(POS=="C", 240,
ifelse(POS=="SS", 168,
ifelse(POS=="2B", 132,
ifelse(POS=="3B", 84,
ifelse(POS=="OF", 48,
ifelse(POS=="1B", 12, 0)))))))
similar(mantle.id, 6)
C.totals$VALUE.POS <- with(C.totals,
ifelse(POS=="C", 240,
ifelse(POS=="SS", 168,
ifelse(POS=="2B", 132,
ifelse(POS=="3B", 84,
ifelse(POS=="OF", 48,
ifelse(POS=="1B", 12, 0)))))))
similar(mantle.id, 6)
C.totals <- C.totals[order(C.totals$SS, decreasing==TRUE)]
C.totals <- C.totals[order(C.totals$SS, decreasing==TRUE),]
C.totals <- C.totals[order(C.totals$SS, decreasing=TRUE),]
C.totals$SS
rm(list=ls())
chapter_path = "C:/Users/conno/Documents/GitHub/Baseball/Analyzing Baseball Data With R/Book - First Edition/Chapter 8 - Career Trajectories"
setwd(chapter_path)
Fielding <- read.csv("Fielding.csv")
Batting <- read.csv("Batting.csv")
People <- read.csv("People.csv")
mantle.info <- subset(People, nameFirst=="Mickey" & nameLast=="Mantle")
mantle.id <- as.character(mantle.info$playerID)
# Analyze trajectories by position
# First only get batters with 2000 Career PA
library(plyr)
AB.totals <- ddply(Batting, .(playerID), summarize,
Career.AB=sum(AB, na.rm=TRUE))
Batting <- merge(Batting, AB.totals)
Batting.2000 <- subset(Batting, Career.AB > 2000)
# Create function to find a player's most common position
find.position <- function(p){
positions <- c("OF", "1B", "2B", "3B", "SS", "C", "P", "DH")
d <- subset(Fielding, playerID==p)
count.games <- function(po)
sum(subset(d, POS==po)$G)
FLD <- sapply(positions, count.games)
positions[FLD == max(FLD)][1]
}
# Create dataframe with fielding positions and playerIDs for players > 2000 PA
PLAYER <- as.character(unique(Batting.2000$playerID))
POSITIONS <- sapply(PLAYER, find.position)
Fielding.2000 <- data.frame(playerID=names(POSITIONS), POS=POSITIONS)
Batting.2000 <- merge(Batting.2000, Fielding.2000)
# Calculate Career Statistics
C.totals <- ddply(Batting.2000, .(playerID), summarize,
C.G=sum(G, na.rm=TRUE),
C.AB=sum(AB, na.rm=TRUE),
C.R=sum(R, na.rm=TRUE),
C.H=sum(H, na.rm=TRUE),
C.2B=sum(X2B, na.rm=TRUE),
C.3B=sum(X3B, na.rm=TRUE),
C.HR=sum(HR, na.rm=TRUE),
C.RBI=sum(RBI, na.rm=TRUE),
C.BB=sum(BB, na.rm=TRUE),
C.SO=sum(SO, na.rm=TRUE),
C.SB=sum(SB, na.rm=TRUE))
# Calculalte batting and slugging
C.totals$C.AVG <- with(C.totals, C.H / C.AB)
C.totals$C.SLG <- with(C.totals, C.H - C.2B - C.3B - C.HR + 2*C.2B + 3*C.3B
+ 4*C.HR)
# Compute Career totals with fielding totals. Each position is given an
# associated fielding value for similarity scores
C.totals <- merge(C.totals, Fielding.2000)
C.totals$VALUE.POS <- with(C.totals,
ifelse(POS=="C", 240,
ifelse(POS=="SS", 168,
ifelse(POS=="2B", 132,
ifelse(POS=="3B", 84,
ifelse(POS=="OF", 48,
ifelse(POS=="1B", 12, 0)))))))
# Computing Bill James Similarity Score
similar <- function(p, number=10){
P <- subset(C.totals, playerID==p)
C.totals$SS <- with(C.totals,
1000 -
floor(abs(C.G - P$C.G) / 20) -
floor(abs(C.AB - P$C.AB) / 75) -
floor(abs(C.R - P$C.R) / 10) -
floor(abs(C.H - P$C.H) / 15) -
floor(abs(C.2B - P$C.2B) / 5) -
floor(abs(C.3B - P$C.3B) / 4) -
floor(abs(C.HR - P$C.HR) / 2) -
floor(abs(C.RBI - P$C.RBI) / 10) -
floor(abs(C.BB - P$C.BB) / 25) -
floor(abs(C.SO - P$C.SO) / 150) -
floor(abs(C.SB - P$C.SB) / 20) -
floor(abs(C.AVG - P$C.AVG) / 0.001) -
floor(abs(C.SLG - P$C.SLG) / 0.002) -
abs(VALUE.POS - P$VALUE.POS))
C.totals <- C.totals[order(C.totals$SS, decreasing=TRUE),]
C.totals[1:number,]
}
similar(mantle.id, 6)
rm(list=ls())
chapter_path = "C:/Users/conno/Documents/GitHub/Baseball/Analyzing Baseball Data With R/Book - First Edition/Chapter 9 - Simulation"
setwd(chapter_path)
rm(list=ls())
# Simulating a Half Inning
# read in 2011 play by play data
data2011 <- read.csv("all2011.csv")
fields <- read.csv("fields.csv")
names(data2011) <- fields[,"Header"]
# We want to calculate the runs scored for the remaining of the inning
# First calculate the runs at a given time
data2011$RUNS <- with(data2011, AWAY_SCORE_CT + HOME_SCORE_CT)
# Create a unique ID for each half inning
data2011$HALF.INNING <- with(data2011, paste(GAME_ID, INN_CT, BAT_HOME_ID))
# Now we will calculate how many runs were scored at the end of the inning
# Calculate the number of runs scored during each play
data2011$RUNS.SCORED <- with(data2011, (BAT_DEST_ID > 3) + (RUN1_DEST_ID > 3)
+ (RUN2_DEST_ID > 3) + (RUN3_DEST_ID > 3))
# Aggregate to sum the runs scored on each play to determine the number of
# runs scored in the half inning
RUNS.SCORED.INNING <- aggregate(data2011$RUNS.SCORED,
list(HALF.INNING=data2011$HALF.INNING), sum)
# Find the total game runs at the beginning of the inning with "[" function
RUNS.SCORED.START <- aggregate(data2011$RUNS,
list(HALF.INNING=data2011$HALF.INNING), "[", 1)
# Get the maximum number of runs in the half inning
MAX <- data.frame(HALF.INNING=RUNS.SCORED.START$HALF.INNING)
MAX$x <- RUNS.SCORED.INNING$x + RUNS.SCORED.START$x
# Merge the data and name the column
data2011 <- merge(data2011, MAX)
names(data2011)[ncol(data2011)] <- "MAX.RUNS"
# Calculate the runs for the remainder of the inning. Typo in Book
data2011$RUNS.ROI <- with(data2011, MAX.RUNS - RUNS)
# --------------------------------------------------------
# Create Binary Variable to determine if runner is on a base before play
RUNNER1 <- ifelse(as.character(data2011[,"BASE1_RUN_ID"]) == "", 0, 1)
RUNNER2 <- ifelse(as.character(data2011[,"BASE2_RUN_ID"]) == "", 0, 1)
RUNNER3 <- ifelse(as.character(data2011[,"BASE3_RUN_ID"]) == "", 0, 1)
# Create function to get the current state dependent on baserunners and outs
get.state <- function(r1, r2, r3, outs){
runners <- paste(r1, r2, r3, sep="")
paste(runners, outs)
}
# Add states to 2011 data
data2011$STATE <- get.state(RUNNER1, RUNNER2, RUNNER3, data2011$OUTS_CT)
# Create Binary Variable to determine if a runner is on a base after play
NRUNNER1 <- with(data2011, as.numeric(RUN1_DEST_ID == 1 |
BAT_DEST_ID == 1))
NRUNNER2 <- with(data2011, as.numeric(RUN1_DEST_ID == 2 |
RUN2_DEST_ID == 2 | BAT_DEST_ID == 2))
NRUNNER3 <- with(data2011, as.numeric(RUN1_DEST_ID == 3 |
RUN2_DEST_ID == 3 | RUN3_DEST_ID == 3 | BAT_DEST_ID == 3))
# Get number of outs at the end of play
NOUTS <- with(data2011, OUTS_CT + EVENT_OUTS_CT)
# Get the new state
data2011$NEW.STATE <- get.state(NRUNNER1, NRUNNER2, NRUNNER3, NOUTS)
# Reduce dataframe to when states change or runs score
data2011 <- subset(data2011, (STATE != NEW.STATE) | (RUNS.SCORED) > 0)
# filter out half innings that are walk-offs because they are not complete
# innings
library(plyr)
data.outs <- ddply(data2011, .(HALF.INNING), summarize,
Outs.Inning=sum(EVENT_OUTS_CT))
data2011 <- merge(data2011, data.outs)
data2011c <- subset(data2011, Outs.Inning==3)
# Get only batting events
data2011c <- subset(data2011c, BAT_EVENT_FL == TRUE)
data2011c$NEW.STATE <- recode(data2011c$NEW.STATE, "c('000 3', '100 3', '010 3',
'001 3', '110 3', '101' 3', '011 3', '111 3',)
='3'")
data2011c$NEW.STATE <- recode(data2011c$NEW.STATE,
"c('000 3', '100 3', '010 3', '001 3',
'110 3', '101' 3', '011 3', '111 3')='3'")
data2011c$NEW.STATE <- recode(data2011c$NEW.STATE,
"c('000 3', '100 3', '010 3', '001 3',
'110 3', '101 3', '011 3', '111 3')='3'")
# Get frequency matrix
T.matrix <- with(data2011c, table(STATE, NEW.STATE))
T.matri
T.matrix
# Turn into a probability matrix
P.matrix <- prop.table(T.matrix)
P.matrix
# Turn into a probability matrix
P.matrix <- prop.table(T.matrix, 1)
P.matrix
# Add row that corresponds to three outs. Cannot transition out of this
P.matrix <- rbind(P.matrix, c(rep(0, 24), 1))
P.matrix
# Get frequency matrix
T.matrix <- with(data2011c, table(STATE, NEW.STATE))
# Turn into a probability matrix
P.matrix <- prop.table(T.matrix, 1)
# Add row that corresponds to three outs. Cannot transition out of this
P.matrix <- rbind(P.matrix, c(rep(0, 24), 1))
# Number of runs is equal to. Quantity (1 + # runners at end of play + # outs
# at end of play) MINUS Quantity (# runners at beginning of play + # outs
# at beginning of play)
# Create function to calculate runs for each transtion. Note there may be some
# large numbers and negative numbers for transitions taht do not actually exist
# e.g. 0 outs 0 runners to 3 outs
count.runners.outs <- function(s)
sum(as.numeric(strsplit(s, "")[[1]]), na.rm=TRUE)
runners.outs <- sapply(dimnames(T.matrix[[1]]), count.runners.outs)[[-25]]
R <- outer9(runners.outs + 1, runners.outs, FUN="-")
dimnames(R)[[1]] <- dimnames(T.matrix[[1]])[-25]
dimnames(R)[[2]] <- dimnames(T.matrix[[1]])[-25]
R <- cbind(R, rep(0, 24))
T.matrix[[1]]
T.matrix
dimnames(T.matrix)
dimnames(T.matrix)[[1]]
dimnames(T.matrix)[[1]][[1]]
a <- dimnames(T.matrix)[[1]][[1]]
count.runners.outs(a)
strsplit(a)
strsplit(a, "")
strsplit(a, "")[[1]]
count.runners.outs <- function(s)
sum(as.numeric(strsplit(s, "")[[1]]), na.rm=TRUE)
runners.outs <- sapply(dimnames(T.matrix[[1]]), count.runners.outs)[[-25]]
dimnames(T.matrix)[[-25]]
dimnames(T.matrix)[[-24]]
dimnames(T.matrix)[[-2]]
dimnames(T.matrix)[[-3]]
count.runners.outs <- function(s)
sum(as.numeric(strsplit(s, "")[[1]]), na.rm=TRUE)
runners.outs <- sapply(dimnames(T.matrix[[1]]), count.runners.outs)[-25]
R <- outer9(runners.outs + 1, runners.outs, FUN="-")
dimnames(R)[[1]] <- dimnames(T.matrix[[1]])[-25]
dimnames(R)[[2]] <- dimnames(T.matrix[[1]])[-25]
R <- cbind(R, rep(0, 24))
runners.outs
count.runners.outs <- function(s)
sum(as.numeric(strsplit(s, " ")[[1]]), na.rm=TRUE)
runners.outs <- sapply(dimnames(T.matrix[[1]]), count.runners.outs)[-25]
runners.outs
dimnames(T.matrix[[1]])
count.runners.outs <- function(s)
sum(as.numeric(strsplit(s, "")[[1]]), na.rm=TRUE)
runners.outs <- sapply(dimnames(T.matrix)[[1]], count.runners.outs)[-25]
runners.outs
runners.outs <- sapply(dimnames(T.matrix)[[1]], count.runners.outs)
runners.outs
count.runners.outs <- function(s)
sum(as.numeric(strsplit(s, "")[[1]]), na.rm=TRUE)
runners.outs <- sapply(dimnames(T.matrix)[[1]], count.runners.outs)[-25]
R <- outer9(runners.outs + 1, runners.outs, FUN="-")
dimnames(R)[[1]] <- dimnames(T.matrix[[1]])[-25]
dimnames(R)[[2]] <- dimnames(T.matrix[[1]])[-25]
R <- cbind(R, rep(0, 24))
R <- outer(runners.outs + 1, runners.outs, FUN="-")
R
count.runners.outs <- function(s)
sum(as.numeric(strsplit(s, "")[[1]]), na.rm=TRUE)
runners.outs <- sapply(dimnames(T.matrix)[[1]], count.runners.outs)[-25]
R <- outer(runners.outs + 1, runners.outs, FUN="-")
dimnames(R)[[1]] <- dimnames(T.matrix[[1]])[-25]
dimnames(R)[[2]] <- dimnames(T.matrix[[1]])[-25]
R <- cbind(R, rep(0, 24))
R
count.runners.outs <- function(s)
sum(as.numeric(strsplit(s, "")[[1]]), na.rm=TRUE)
runners.outs <- sapply(dimnames(T.matrix)[[1]], count.runners.outs)[-25]
R <- outer(runners.outs + 1, runners.outs, FUN="-")
dimnames(R)[[1]] <- dimnames(T.matrix[[1]])[-25]
dimnames(R)[[2]] <- dimnames(T.matrix[[1]])[-25]
R <- cbind(R, rep(0, 24))
# Write function to simulate a half inning
simulate.half.inning <- function(P, R, start=1){
s <- start
path <- NULL
runs <- 0
while(s < 25){
s.new <- sample(1:25, 1, prob=P[s,])
path <- c(path, s.new)
runs <- runs + R[s, s.new]
s <- s.new
}
runs
}
# Simulate 10,000 half innings
RUNS <- replicate(10000, simulate.half.inning(T.matrix, R))
table(RUNS)
mean(RUNS)
# We can use matrix multiplication to see the state after 3 plate appearances
P.matrix3 <- P.matrix %*% P.matrix %*% P.matrix
P.matrix3 <- P.matrix %*% P.matrix %*% P.matrix
sortedP <- sort(round(P.matrix3["000 0",], 3), decreasing=TRUE)
head(data.frame(Prob=sortedP))
Q <- P.matrix[-25, -25]
Q
P.matrix
N <- solve(diag(rep(0, 24), Q))
Q
Q <- P.matrix[-25, -25]
N <- solve(diag(rep(0, 24), Q))
N <- solve(diag(rep(0, 24) - Q))
diag(rep(0,3))
diag(rep(1,3))
N <- solve(diag(rep(1, 24)) - Q))
N <- solve(diag(rep(1, 24)) - Q)
N
