RUNS.SCORED.START <- aggregate(data2011$RUNS,
list(HALF.INNING=data2011$HALF.INNING), "[", 1)
# Get the maximum number of runs in the half inning
MAX <- data.frame(HALF.INNING=RUNS.SCORED.START$HALF.INNING)
MAX$x <- RUNS.SCORED.INNING$x + RUNS.SCORED.START$x
# Merge the data and name the column
data2011 <- merge(data2011, MAX)
names(data2011)[ncol(data2011)] <- "MAX.RUNS"
# Calculate the runs for the remainder of the inning. Typo in Book
data2011$RUNS.ROI <- with(data2011, MAX.RUNS - RUNS)
# --------------------------------------------------------
# Create Binary Variable to determine if runner is on a base before play
RUNNER1 <- ifelse(as.character(data2011[,"BASE1_RUN_ID"]) == "", 0, 1)
RUNNER2 <- ifelse(as.character(data2011[,"BASE2_RUN_ID"]) == "", 0, 1)
RUNNER3 <- ifelse(as.character(data2011[,"BASE3_RUN_ID"]) == "", 0, 1)
# Create function to get the current state dependent on baserunners and outs
get.state <- function(r1, r2, r3, outs){
runners <- paste(r1, r2, r3, sep="")
paste(runners, outs)
}
# Add states to 2011 data
data2011$STATE <- get.state(RUNNER1, RUNNER2, RUNNER3, data2011$OUTS_CT)
# Create Binary Variable to determine if a runner is on a base after play
NRUNNER1 <- with(data2011, as.numeric(RUN1_DEST_ID == 1 |
BAT_DEST_ID == 1))
NRUNNER2 <- with(data2011, as.numeric(RUN1_DEST_ID == 2 |
RUN2_DEST_ID == 2 | BAT_DEST_ID == 2))
NRUNNER3 <- with(data2011, as.numeric(RUN1_DEST_ID == 3 |
RUN2_DEST_ID == 3 | RUN3_DEST_ID == 3 | BAT_DEST_ID == 3))
# Get number of outs at the end of play
NOUTS <- with(data2011, OUTS_CT + EVENT_OUTS_CT)
# Get the new state
data2011$NEW.STATE <- get.state(NRUNNER1, NRUNNER2, NRUNNER3, NOUTS)
# Reduce dataframe to when states change or runs score
data2011 <- subset(data2011, (STATE != NEW.STATE) | (RUNS.SCORED) > 0)
# filter out half innings that are walk-offs because they are not complete
# innings
library(plyr)
data.outs <- ddply(data2011, .(HALF.INNING), summarize,
Outs.Inning=sum(EVENT_OUTS_CT))
data2011 <- merge(data2011, data.outs)
data2011c <- subset(data2011, Outs.Inning==3)
# Calculate the expected number of runs for each element of the matrix
RUNS <- with(data2011c, aggregate(RUNS.ROI, list(STATE), mean))
# Display matrix. First order by out then create matrix
# Get the 5th character to the 5th character in the string
RUNS$OUTS <- substr(RUNS$Group.1, 5, 5)
RUNS <- RUNS[order(RUNS$OUTS),]
RUNS.out <- matrix(round(RUNS$x, 2), 8, 3)
dimnames(RUNS.out)[[2]] <- c("0 outs", "1 out", "2 outs")
dimnames(RUNS.out)[[1]] <- c("000", "001", "010", "011", "100", "101", "110", "111")
RUNS.out
names(data2011)
RUNS.SCORED.INNING
head(RUNS.SCORED.INNING)
data2011$RUNS.SCORED.INNING
head(RUNS.SCORED.INNING, 10)
nrow(data2011$RUNS.SCORED)
rm(list=ls())
# In Section 5.3, the construction of the run expectancy matrix from 2011
# season data was illustrated. Suppose instead that one was interested in
# computing the proportion of times when at least one run was scored for each
# of the 24 possible bases/outs situations. Use R to construct this probability
# of scoring matrix
chapter_path = "C:/Users/conno/Documents/GitHub/Baseball/Analyzing Baseball Data With R/Book - First Edition/Chapter 5 - Value of Plays Using Run Expectancy"
setwd(chapter_path)
# read in 2011 play by play data
data2011 <- read.csv("all2011.csv")
fields <- read.csv("fields.csv")
names(data2011) <- fields[,"Header"]
# We want to calculate the runs scored for the remaining of the inning
# First calculate the runs at a given time
data2011$RUNS <- with(data2011, AWAY_SCORE_CT + HOME_SCORE_CT)
# Create a unique ID for each half inning
data2011$HALF.INNING <- with(data2011, paste(GAME_ID, INN_CT, BAT_HOME_ID))
# Now we will calculate how many runs were scored at the end of the inning
# Calculate the number of runs scored during each play
data2011$RUNS.SCORED <- with(data2011, (BAT_DEST_ID > 3) + (RUN1_DEST_ID > 3)
+ (RUN2_DEST_ID > 3) + (RUN3_DEST_ID > 3))
# Aggregate to sum the runs scored on each play to determine the number of
# runs scored in the half inning
RUNS.SCORED.INNING <- aggregate(data2011$RUNS.SCORED,
list(HALF.INNING=data2011$HALF.INNING), sum)
# Find the total game runs at the beginning of the inning with "[" function
RUNS.SCORED.START <- aggregate(data2011$RUNS,
list(HALF.INNING=data2011$HALF.INNING), "[", 1)
# Get the maximum number of runs in the half inning
MAX <- data.frame(HALF.INNING=RUNS.SCORED.START$HALF.INNING)
MAX$x <- RUNS.SCORED.INNING$x + RUNS.SCORED.START$x
# Merge the data and name the column
data2011 <- merge(data2011, MAX)
names(data2011)[ncol(data2011)] <- "MAX.RUNS"
# Calculate the runs for the remainder of the inning. Typo in Book
data2011$RUNS.ROI <- with(data2011, MAX.RUNS - RUNS)
# --------------------------------------------------------
# Create Binary Variable to determine if runner is on a base before play
RUNNER1 <- ifelse(as.character(data2011[,"BASE1_RUN_ID"]) == "", 0, 1)
RUNNER2 <- ifelse(as.character(data2011[,"BASE2_RUN_ID"]) == "", 0, 1)
RUNNER3 <- ifelse(as.character(data2011[,"BASE3_RUN_ID"]) == "", 0, 1)
# Create function to get the current state dependent on baserunners and outs
get.state <- function(r1, r2, r3, outs){
runners <- paste(r1, r2, r3, sep="")
paste(runners, outs)
}
# Add states to 2011 data
data2011$STATE <- get.state(RUNNER1, RUNNER2, RUNNER3, data2011$OUTS_CT)
# Create Binary Variable to determine if a runner is on a base after play
NRUNNER1 <- with(data2011, as.numeric(RUN1_DEST_ID == 1 |
BAT_DEST_ID == 1))
NRUNNER2 <- with(data2011, as.numeric(RUN1_DEST_ID == 2 |
RUN2_DEST_ID == 2 | BAT_DEST_ID == 2))
NRUNNER3 <- with(data2011, as.numeric(RUN1_DEST_ID == 3 |
RUN2_DEST_ID == 3 | RUN3_DEST_ID == 3 | BAT_DEST_ID == 3))
# Get number of outs at the end of play
NOUTS <- with(data2011, OUTS_CT + EVENT_OUTS_CT)
# Get the new state
data2011$NEW.STATE <- get.state(NRUNNER1, NRUNNER2, NRUNNER3, NOUTS)
# Reduce dataframe to when states change or runs score
data2011 <- subset(data2011, (STATE != NEW.STATE) | (RUNS.SCORED) > 0)
# filter out half innings that are walk-offs because they are not complete
# innings
library(plyr)
data.outs <- ddply(data2011, .(HALF.INNING), summarize,
Outs.Inning=sum(EVENT_OUTS_CT))
data2011 <- merge(data2011, data.outs)
data2011c <- subset(data2011, Outs.Inning==3)
# Calculate the expected number of runs for each element of the matrix
RUNS <- with(data2011c, aggregate(RUNS.ROI, list(STATE), mean))
# Display matrix. First order by out then create matrix
# Get the 5th character to the 5th character in the string
RUNS$OUTS <- substr(RUNS$Group.1, 5, 5)
RUNS <- RUNS[order(RUNS$OUTS),]
RUNS.out <- matrix(round(RUNS$x, 2), 8, 3)
dimnames(RUNS.out)[[2]] <- c("0 outs", "1 out", "2 outs")
dimnames(RUNS.out)[[1]] <- c("000", "001", "010", "011", "100", "101", "110", "111")
# Calculate whether a run scored in the inning
data2011$IF.SCORED <- with(data2011, as.numeric(MAX.RUNS - RUNS > 0))
rm(list=ls())
# In Section 5.3, the construction of the run expectancy matrix from 2011
# season data was illustrated. Suppose instead that one was interested in
# computing the proportion of times when at least one run was scored for each
# of the 24 possible bases/outs situations. Use R to construct this probability
# of scoring matrix
chapter_path = "C:/Users/conno/Documents/GitHub/Baseball/Analyzing Baseball Data With R/Book - First Edition/Chapter 5 - Value of Plays Using Run Expectancy"
setwd(chapter_path)
# read in 2011 play by play data
data2011 <- read.csv("all2011.csv")
fields <- read.csv("fields.csv")
names(data2011) <- fields[,"Header"]
# We want to calculate the runs scored for the remaining of the inning
# First calculate the runs at a given time
data2011$RUNS <- with(data2011, AWAY_SCORE_CT + HOME_SCORE_CT)
# Create a unique ID for each half inning
data2011$HALF.INNING <- with(data2011, paste(GAME_ID, INN_CT, BAT_HOME_ID))
# Now we will calculate how many runs were scored at the end of the inning
# Calculate the number of runs scored during each play
data2011$RUNS.SCORED <- with(data2011, (BAT_DEST_ID > 3) + (RUN1_DEST_ID > 3)
+ (RUN2_DEST_ID > 3) + (RUN3_DEST_ID > 3))
# Aggregate to sum the runs scored on each play to determine the number of
# runs scored in the half inning
RUNS.SCORED.INNING <- aggregate(data2011$RUNS.SCORED,
list(HALF.INNING=data2011$HALF.INNING), sum)
# Find the total game runs at the beginning of the inning with "[" function
RUNS.SCORED.START <- aggregate(data2011$RUNS,
list(HALF.INNING=data2011$HALF.INNING), "[", 1)
# Get the maximum number of runs in the half inning
MAX <- data.frame(HALF.INNING=RUNS.SCORED.START$HALF.INNING)
MAX$x <- RUNS.SCORED.INNING$x + RUNS.SCORED.START$x
# Merge the data and name the column
data2011 <- merge(data2011, MAX)
names(data2011)[ncol(data2011)] <- "MAX.RUNS"
# Calculate the runs for the remainder of the inning
data2011$RUNS.ROI <- with(data2011, MAX.RUNS - RUNS)
# Calculate whether a run scored in the inning
data2011$IF.SCORED <- with(data2011, as.numeric(MAX.RUNS - RUNS > 0))
# --------------------------------------------------------
# Create Binary Variable to determine if runner is on a base before play
RUNNER1 <- ifelse(as.character(data2011[,"BASE1_RUN_ID"]) == "", 0, 1)
RUNNER2 <- ifelse(as.character(data2011[,"BASE2_RUN_ID"]) == "", 0, 1)
RUNNER3 <- ifelse(as.character(data2011[,"BASE3_RUN_ID"]) == "", 0, 1)
# Create function to get the current state dependent on baserunners and outs
get.state <- function(r1, r2, r3, outs){
runners <- paste(r1, r2, r3, sep="")
paste(runners, outs)
}
# Add states to 2011 data
data2011$STATE <- get.state(RUNNER1, RUNNER2, RUNNER3, data2011$OUTS_CT)
# Create Binary Variable to determine if a runner is on a base after play
NRUNNER1 <- with(data2011, as.numeric(RUN1_DEST_ID == 1 |
BAT_DEST_ID == 1))
NRUNNER2 <- with(data2011, as.numeric(RUN1_DEST_ID == 2 |
RUN2_DEST_ID == 2 | BAT_DEST_ID == 2))
NRUNNER3 <- with(data2011, as.numeric(RUN1_DEST_ID == 3 |
RUN2_DEST_ID == 3 | RUN3_DEST_ID == 3 | BAT_DEST_ID == 3))
# Get number of outs at the end of play
NOUTS <- with(data2011, OUTS_CT + EVENT_OUTS_CT)
# Get the new state
data2011$NEW.STATE <- get.state(NRUNNER1, NRUNNER2, NRUNNER3, NOUTS)
# Reduce dataframe to when states change or runs score
data2011 <- subset(data2011, (STATE != NEW.STATE) | (RUNS.SCORED) > 0)
# filter out half innings that are walk-offs because they are not complete
# innings
library(plyr)
data.outs <- ddply(data2011, .(HALF.INNING), summarize,
Outs.Inning=sum(EVENT_OUTS_CT))
data2011 <- merge(data2011, data.outs)
data2011c <- subset(data2011, Outs.Inning==3)
# Calculate the expected number of runs for each element of the matrix
RUNS <- with(data2011c, aggregate(RUNS.IF.SCORED, list(STATE), mean))
# Display matrix. First order by out then create matrix
# Get the 5th character to the 5th character in the string
RUNS$OUTS <- substr(RUNS$Group.1, 5, 5)
RUNS <- RUNS[order(RUNS$OUTS),]
RUNS.out <- matrix(round(RUNS$x, 2), 8, 3)
dimnames(RUNS.out)[[2]] <- c("0 outs", "1 out", "2 outs")
dimnames(RUNS.out)[[1]] <- c("000", "001", "010", "011", "100", "101", "110", "111")
data2011$NEW.STATE <- get.state(NRUNNER1, NRUNNER2, NRUNNER3, NOUTS)
# Reduce dataframe to when states change or runs score
data2011 <- subset(data2011, (STATE != NEW.STATE) | (RUNS.SCORED) > 0)
# filter out half innings that are walk-offs because they are not complete
# innings
library(plyr)
data.outs <- ddply(data2011, .(HALF.INNING), summarize,
Outs.Inning=sum(EVENT_OUTS_CT))
data2011 <- merge(data2011, data.outs)
data2011c <- subset(data2011, Outs.Inning==3)
# Calculate the expected number of runs for each element of the matrix
RUNS <- with(data2011c, aggregate(IF.SCORED, list(STATE), mean))
# Display matrix. First order by out then create matrix
# Get the 5th character to the 5th character in the string
RUNS$OUTS <- substr(RUNS$Group.1, 5, 5)
RUNS <- RUNS[order(RUNS$OUTS),]
RUNS.out <- matrix(round(RUNS$x, 2), 8, 3)
dimnames(RUNS.out)[[2]] <- c("0 outs", "1 out", "2 outs")
dimnames(RUNS.out)[[1]] <- c("000", "001", "010", "011", "100", "101", "110", "111")
rm(list=ls())
# In Section 5.3, the construction of the run expectancy matrix from 2011
# season data was illustrated. Suppose instead that one was interested in
# computing the proportion of times when at least one run was scored for each
# of the 24 possible bases/outs situations. Use R to construct this probability
# of scoring matrix
chapter_path = "C:/Users/conno/Documents/GitHub/Baseball/Analyzing Baseball Data With R/Book - First Edition/Chapter 5 - Value of Plays Using Run Expectancy"
setwd(chapter_path)
# read in 2011 play by play data
data2011 <- read.csv("all2011.csv")
fields <- read.csv("fields.csv")
names(data2011) <- fields[,"Header"]
# We want to calculate the runs scored for the remaining of the inning
# First calculate the runs at a given time
data2011$RUNS <- with(data2011, AWAY_SCORE_CT + HOME_SCORE_CT)
# Create a unique ID for each half inning
data2011$HALF.INNING <- with(data2011, paste(GAME_ID, INN_CT, BAT_HOME_ID))
# Now we will calculate how many runs were scored at the end of the inning
# Calculate the number of runs scored during each play
data2011$RUNS.SCORED <- with(data2011, (BAT_DEST_ID > 3) + (RUN1_DEST_ID > 3)
+ (RUN2_DEST_ID > 3) + (RUN3_DEST_ID > 3))
# Aggregate to sum the runs scored on each play to determine the number of
# runs scored in the half inning
RUNS.SCORED.INNING <- aggregate(data2011$RUNS.SCORED,
list(HALF.INNING=data2011$HALF.INNING), sum)
# Find the total game runs at the beginning of the inning with "[" function
RUNS.SCORED.START <- aggregate(data2011$RUNS,
list(HALF.INNING=data2011$HALF.INNING), "[", 1)
# Get the maximum number of runs in the half inning
MAX <- data.frame(HALF.INNING=RUNS.SCORED.START$HALF.INNING)
MAX$x <- RUNS.SCORED.INNING$x + RUNS.SCORED.START$x
# Merge the data and name the column
data2011 <- merge(data2011, MAX)
names(data2011)[ncol(data2011)] <- "MAX.RUNS"
# Calculate the runs for the remainder of the inning
data2011$RUNS.ROI <- with(data2011, MAX.RUNS - RUNS)
# Calculate whether a run scored in the inning
data2011$IF.SCORED <- with(data2011, as.numeric(MAX.RUNS - RUNS > 0))
# --------------------------------------------------------
# Create Binary Variable to determine if runner is on a base before play
RUNNER1 <- ifelse(as.character(data2011[,"BASE1_RUN_ID"]) == "", 0, 1)
RUNNER2 <- ifelse(as.character(data2011[,"BASE2_RUN_ID"]) == "", 0, 1)
RUNNER3 <- ifelse(as.character(data2011[,"BASE3_RUN_ID"]) == "", 0, 1)
# Create function to get the current state dependent on baserunners and outs
get.state <- function(r1, r2, r3, outs){
runners <- paste(r1, r2, r3, sep="")
paste(runners, outs)
}
# Add states to 2011 data
data2011$STATE <- get.state(RUNNER1, RUNNER2, RUNNER3, data2011$OUTS_CT)
# Create Binary Variable to determine if a runner is on a base after play
NRUNNER1 <- with(data2011, as.numeric(RUN1_DEST_ID == 1 |
BAT_DEST_ID == 1))
NRUNNER2 <- with(data2011, as.numeric(RUN1_DEST_ID == 2 |
RUN2_DEST_ID == 2 | BAT_DEST_ID == 2))
NRUNNER3 <- with(data2011, as.numeric(RUN1_DEST_ID == 3 |
RUN2_DEST_ID == 3 | RUN3_DEST_ID == 3 | BAT_DEST_ID == 3))
# Get number of outs at the end of play
NOUTS <- with(data2011, OUTS_CT + EVENT_OUTS_CT)
# Get the new state
data2011$NEW.STATE <- get.state(NRUNNER1, NRUNNER2, NRUNNER3, NOUTS)
# Reduce dataframe to when states change or runs score
data2011 <- subset(data2011, (STATE != NEW.STATE) | (RUNS.SCORED) > 0)
# filter out half innings that are walk-offs because they are not complete
# innings
library(plyr)
data.outs <- ddply(data2011, .(HALF.INNING), summarize,
Outs.Inning=sum(EVENT_OUTS_CT))
data2011 <- merge(data2011, data.outs)
data2011c <- subset(data2011, Outs.Inning==3)
# Calculate the expected number of runs for each element of the matrix
RUNS <- with(data2011c, aggregate(IF.SCORED, list(STATE), mean))
# Display matrix. First order by out then create matrix
# Get the 5th character to the 5th character in the string
RUNS$OUTS <- substr(RUNS$Group.1, 5, 5)
RUNS <- RUNS[order(RUNS$OUTS),]
RUNS.out <- matrix(round(RUNS$x, 2), 8, 3)
dimnames(RUNS.out)[[2]] <- c("0 outs", "1 out", "2 outs")
dimnames(RUNS.out)[[1]] <- c("000", "001", "010", "011", "100", "101", "110", "111")
RUNS.out
rm(list=ls())
# Runner Advancement with a Single
rm(list=ls())
# Run Values of Hits
# In Section 5.8, we found the average run vaalue of a home run and a single
# (a)
# Use similar R code as described in Section 5.8 for the 2011 season data to
# find the mean run values for a double and for a triple
# read in 2011 play by play data
data2011 <- read.csv("all2011.csv")
fields <- read.csv("fields.csv")
names(data2011) <- fields[,"Header"]
# We want to calculate the runs scored for the remaining of the inning
# First calculate the runs at a given time
data2011$RUNS <- with(data2011, AWAY_SCORE_CT + HOME_SCORE_CT)
# Create a unique ID for each half inning
data2011$HALF.INNING <- with(data2011, paste(GAME_ID, INN_CT, BAT_HOME_ID))
# Now we will calculate how many runs were scored at the end of the inning
# Calculate the number of runs scored during each play
data2011$RUNS.SCORED <- with(data2011, (BAT_DEST_ID > 3) + (RUN1_DEST_ID > 3)
+ (RUN2_DEST_ID > 3) + (RUN3_DEST_ID > 3))
# Aggregate to sum the runs scored on each play to determine the number of
# runs scored in the half inning
RUNS.SCORED.INNING <- aggregate(data2011$RUNS.SCORED,
list(HALF.INNING=data2011$HALF.INNING), sum)
# Find the total game runs at the beginning of the inning with "[" function
RUNS.SCORED.START <- aggregate(data2011$RUNS,
list(HALF.INNING=data2011$HALF.INNING), "[", 1)
# Get the maximum number of runs in the half inning
MAX <- data.frame(HALF.INNING=RUNS.SCORED.START$HALF.INNING)
MAX$x <- RUNS.SCORED.INNING$x + RUNS.SCORED.START$x
# Merge the data and name the column
data2011 <- merge(data2011, MAX)
names(data2011)[ncol(data2011)] <- "MAX.RUNS"
# Calculate the runs for the remainder of the inning. Typo in Book
data2011$RUNS.ROI <- with(data2011, MAX.RUNS - RUNS)
# --------------------------------------------------------
# Create Binary Variable to determine if runner is on a base before play
RUNNER1 <- ifelse(as.character(data2011[,"BASE1_RUN_ID"]) == "", 0, 1)
RUNNER2 <- ifelse(as.character(data2011[,"BASE2_RUN_ID"]) == "", 0, 1)
RUNNER3 <- ifelse(as.character(data2011[,"BASE3_RUN_ID"]) == "", 0, 1)
# Create function to get the current state dependent on baserunners and outs
get.state <- function(r1, r2, r3, outs){
runners <- paste(r1, r2, r3, sep="")
paste(runners, outs)
}
# Add states to 2011 data
data2011$STATE <- get.state(RUNNER1, RUNNER2, RUNNER3, data2011$OUTS_CT)
# Create Binary Variable to determine if a runner is on a base after play
NRUNNER1 <- with(data2011, as.numeric(RUN1_DEST_ID == 1 |
BAT_DEST_ID == 1))
NRUNNER2 <- with(data2011, as.numeric(RUN1_DEST_ID == 2 |
RUN2_DEST_ID == 2 | BAT_DEST_ID == 2))
NRUNNER3 <- with(data2011, as.numeric(RUN1_DEST_ID == 3 |
RUN2_DEST_ID == 3 | RUN3_DEST_ID == 3 | BAT_DEST_ID == 3))
# Get number of outs at the end of play
NOUTS <- with(data2011, OUTS_CT + EVENT_OUTS_CT)
# Get the new state
data2011$NEW.STATE <- get.state(NRUNNER1, NRUNNER2, NRUNNER3, NOUTS)
# Reduce dataframe to when states change or runs score
data2011 <- subset(data2011, (STATE != NEW.STATE) | (RUNS.SCORED) > 0)
# filter out half innings that are walk-offs because they are not complete
# innings
library(plyr)
data.outs <- ddply(data2011, .(HALF.INNING), summarize,
Outs.Inning=sum(EVENT_OUTS_CT))
data2011 <- merge(data2011, data.outs)
data2011c <- subset(data2011, Outs.Inning==3)
# Calculate the expected number of runs for each element of the matrix
RUNS <- with(data2011c, aggregate(RUNS.ROI, list(STATE), mean))
# Display matrix. First order by out then create matrix
# Get the 5th character to the 5th character in the string
RUNS$OUTS <- substr(RUNS$Group.1, 5, 5)
RUNS <- RUNS[order(RUNS$OUTS),]
RUNS.out <- matrix(round(RUNS$x, 2), 8, 3)
dimnames(RUNS.out)[[2]] <- c("0 outs", "1 out", "2 outs")
dimnames(RUNS.out)[[1]] <- c("000", "001", "010", "011", "100", "101", "110", "111")
#------------------------------------------------------
# Calculate the run value for each play
# Calculate a potential runs matrix. We know that with 3 outs no more runs can
# be scored
RUNS.POTENTIAL <- matrix(c(RUNS$x, rep(0, 8)), 32, 1)
dimnames(RUNS.POTENTIAL)[[1]] <- c(RUNS$Group.1, "000 3", "001 3", "010 3",
"011 3", "100 3", "101 3", "110 3", "111 3")
# Calculate Runs Value of State Before Play
data2011$RUNS.STATE <- RUNS.POTENTIAL[data2011$STATE,]
# Calculate Runs Value of State After Play
data2011$RUNS.NEW.STATE <- RUNS.POTENTIAL[data2011$NEW.STATE,]
# Calculate Runs Value
data2011$RUNS.VALUE <- data2011$RUNS.NEW.STATE - data2011$RUNS.STATE +
data2011$RUNS.SCORED
# Suppose one is interested in studying how runners move with a single
# (a)
# Using the subset function, select the plays when a single was hit (The value
# of EVENT_CD for a single is 20). Call the new data frame d.single
d.single <- subset(data2011, EVENT_CD==20)
# (b)
# Use the table function with the dataframe d.single to construct a table of
# frequencies of the variables STATE (the beginning runners/outs state) and
# NEW.STATE (the final runners/outs state)
table(d.single$STATE)
# (c)
# Suppose there is a single runner on first base. Using the table from part (b)
# explore where runners move with a single. Is it more likely for the lead
# runner to move to secon, or to third base
# (d)
# Suppose instead there are runners on first and second. Explore where runners
# move with a single. Estimate the probability a run is scored on the play
# (b)
# Use the table function with the dataframe d.single to construct a table of
# frequencies of the variables STATE (the beginning runners/outs state) and
# NEW.STATE (the final runners/outs state)
table(d.single$STATE)
table(d.single$NEW.STATE)
data <- data2011[data2011$STATE=="100 0" | data2011$STATE=="100 1" |
data2011$STATE=="100 2",]
data.single <- subset(data, EVENT_CD==20)
table(data.single$STATE)
table(data.single$NEW.STATE)
data.1st <- data2011[data2011$STATE=="110 0" | data2011$STATE=="110 1" |
data2011$STATE=="110 2",]
data.1st.single <- subset(data, EVENT_CD==20)
table(data.1st.single$STATE)
table(data.1st.single$NEW.STATE)
data.1st.2nd <- data2011[data2011$STATE=="110 0" | data2011$STATE=="110 1" |
data2011$STATE=="110 2",]
data.1st.2nd.single <- subset(data, EVENT_CD==20)
table(data.1st.2nd.single$STATE)
table(data.1st.2nd.single$NEW.STATE)
# Jose  Reyes
gonz.id <- subset(Roster, First.Name=="Adrian" & Last.Name=="Gonzalez")$Player.ID
young.id <- subset(Roster, First.Name=="Michael" & Last.Name=="Young")$Player.ID
reyes.id <- subset(Roster, First.Name=="Jose" & Last.Name=="Reyes")$Player.ID
# Get dataframes of only the players
gonz <- subset(data2011, BAT_ID == gonz.id & BAT_EVENT_FL == TRUE)
young <- subset(data2011, BAT_ID == young.id & BAT_EVENT_FL == TRUE)
reyes <- subset(data2011, BAT_ID == reyes.id & BAT_EVENT_FL == TRUE)
# Get the number of situations with runners and plot against values
gonz$RUNNERS <- substr(gonz$STATE, 1, 3)
young$RUNNERS <- substr(young$STATE, 1, 3)
reyes$RUNNERS <- substr(reyes$STATE, 1, 3)
with(gonz, stripchart(RUNS.VALUE ~ RUNNERS, vertical=TRUE, jitter=0.2,
xlab="RUNNERS", method="jitter", pch=1, cex=0.8))
Roster <- read.csv("roster2011.csv")
# Adrian Gonzalez
# Michael Young
# Jose  Reyes
gonz.id <- subset(Roster, First.Name=="Adrian" & Last.Name=="Gonzalez")$Player.ID
young.id <- subset(Roster, First.Name=="Michael" & Last.Name=="Young")$Player.ID
reyes.id <- subset(Roster, First.Name=="Jose" & Last.Name=="Reyes")$Player.ID
# Get dataframes of only the players
gonz <- subset(data2011, BAT_ID == gonz.id & BAT_EVENT_FL == TRUE)
young <- subset(data2011, BAT_ID == young.id & BAT_EVENT_FL == TRUE)
reyes <- subset(data2011, BAT_ID == reyes.id & BAT_EVENT_FL == TRUE)
# Get the number of situations with runners and plot against values
gonz$RUNNERS <- substr(gonz$STATE, 1, 3)
young$RUNNERS <- substr(young$STATE, 1, 3)
reyes$RUNNERS <- substr(reyes$STATE, 1, 3)
with(gonz, stripchart(RUNS.VALUE ~ RUNNERS, vertical=TRUE, jitter=0.2,
xlab="RUNNERS", method="jitter", pch=1, cex=0.8))
gonz.id
gonz.id
# Read in 2011 roster data
Roster <- read.csv("roster2011.csv")
# Adrian Gonzalez
# Michael Young
# Jose  Reyes
gonz.id <- subset(Roster, First.Name=="Adrian" & Last.Name=="Gonzalez")$Player.ID
gonz.id <- as.character(gonz.id)
young.id <- subset(Roster, First.Name=="Michael" & Last.Name=="Young")$Player.ID
young.id <- as.character(young.id)
reyes.id <- subset(Roster, First.Name=="Jose" & Last.Name=="Reyes")$Player.ID
reyes.id <- as.character(reyes.id)
# Get dataframes of only the players
gonz <- subset(data2011, BAT_ID == gonz.id & BAT_EVENT_FL == TRUE)
young <- subset(data2011, BAT_ID == young.id & BAT_EVENT_FL == TRUE)
reyes <- subset(data2011, BAT_ID == reyes.id & BAT_EVENT_FL == TRUE)
# Get the number of situations with runners and plot against values
gonz$RUNNERS <- substr(gonz$STATE, 1, 3)
young$RUNNERS <- substr(young$STATE, 1, 3)
reyes$RUNNERS <- substr(reyes$STATE, 1, 3)
with(gonz, stripchart(RUNS.VALUE ~ RUNNERS, vertical=TRUE, jitter=0.2,
xlab="RUNNERS", method="jitter", pch=1, cex=0.8))
with(gonz, stripchart(RUNS.VALUE ~ RUNNERS, vertical=TRUE, jitter=0.2,
xlab="RUNNERS", method="jitter", pch=1, cex=0.8,
main="Adrian Gonzalez Run Values"))
with(young, stripchart(RUNS.VALUE ~ RUNNERS, vertical=TRUE, jitter=0.2,
xlab="RUNNERS", method="jitter", pch=1, cex=0.8,
main="Adrian Gonzalez Run Values"))
with(young, stripchart(RUNS.VALUE ~ RUNNERS, vertical=TRUE, jitter=0.2,
xlab="RUNNERS", method="jitter", pch=1, cex=0.8,
main="Michael Young  Run Values"))
# Michael Young  was more unsuccessful than successful with runners in
# scoring position
with(reyes, stripchart(RUNS.VALUE ~ RUNNERS, vertical=TRUE, jitter=0.2,
xlab="RUNNERS", method="jitter", pch=1, cex=0.8,
main="Jose Reyes Run Values"))
